{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.8.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Test_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Int
import Data.Typeable ( Typeable )
import qualified Data.Map as Map
import qualified Data.Set as Set

import Thrift


data Operation = ADD|SUBTRACT|MULTIPLY|DIVIDE  deriving (Show,Eq, Typeable, Ord)
instance Enum Operation where
  fromEnum t = case t of
    ADD -> 1
    SUBTRACT -> 2
    MULTIPLY -> 3
    DIVIDE -> 4
  toEnum t = case t of
    1 -> ADD
    2 -> SUBTRACT
    3 -> MULTIPLY
    4 -> DIVIDE
    _ -> throw ThriftException
data Work = Work{f_Work_num1 :: Maybe Int32,f_Work_num2 :: Maybe Int32,f_Work_op :: Maybe Operation,f_Work_comment :: Maybe String} deriving (Show,Eq,Ord,Typeable)
write_Work oprot record = do
  writeStructBegin oprot "Work"
  case f_Work_num1 record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("num1",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Work_num2 record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("num2",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Work_op record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("op",T_I32,3)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Work_comment record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("comment",T_STRING,4)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Work_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_Work_fields iprot record{f_Work_num1=Just s}
        else do
          skip iprot _t3
          read_Work_fields iprot record
      2 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_Work_fields iprot record{f_Work_num2=Just s}
        else do
          skip iprot _t3
          read_Work_fields iprot record
      3 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Work_fields iprot record{f_Work_op=Just s}
        else do
          skip iprot _t3
          read_Work_fields iprot record
      4 -> if _t3 == T_STRING then do
        s <- readString iprot
        read_Work_fields iprot record{f_Work_comment=Just s}
        else do
          skip iprot _t3
          read_Work_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Work_fields iprot record
read_Work iprot = do
  _ <- readStructBegin iprot
  record <- read_Work_fields iprot (Work{f_Work_num1=Nothing,f_Work_num2=Nothing,f_Work_op=Nothing,f_Work_comment=Nothing})
  readStructEnd iprot
  return record
